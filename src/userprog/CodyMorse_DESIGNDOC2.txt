		     +--------------------------+
       	       	     |		CS 520      	|
		     | PROJECT 2: USER PROGRAMS	|
		     | 	   DESIGN DOCUMENT     	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Jack Johnson <jjohn98@ksu.edu>
Abdulkareem Alkhiary <araasai@ksu.edu>
Cody Morse <cody598@ksu.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

http://www.scs.stanford.edu/07au-cs140/pintos/pintos_3.html
https://www.youtube.com/watch?v=OE79vNZp1KI&ab_channel=FarshadGhanei
https://github.com/danelia/pintos
https://github.com/codyjack/OS-pintos
https://github.com/st2092/pintos-user-programs
https://github.com/Waqee/Pintos-Project-2

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

For our implementation we did not have to incorportate any new data structures into this section of the project.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

Initially we setup the page to be initialized in setup_stack().

Using the Process_execute, a "file_name" is passed with both commands and arguments. The commands and arguments are then tokenized. This is done in order to pass
arguments into: start_process(), load(), and setup_stack().

In order to setup our stack, we first memcpy both the argument string and thread name. Once the strings are lined up, we go through strings backwards to get each token.
Then, the strings are pushed to the page in order to create argv[]. Finally, we create: argv, argc, and return address.

In order to get argv[] in the correct order, the argument string is scanned from back to front. This is done in order to make sure the first token is the last argument from the string.
Then, the stack pointer is decreased in order to setup the remaining argv[] elements.

In order to deal with stack overflow was to fix the stack pointer whenever a failure occurs.
Our group figured this was better than having to check it all the time, which would give us more overhead than if we were just fixing errors that occured.


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

We beleive that strtok_r() was implemented in order to put the address of arguments aside as the kernel seperates the commands and arguments.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1. Seperating commands into an executable name and arguments will shorten kernel time.
2. Seperating commands into an executable name and arguments will make it easier to pass in more than a single set of commands at a time.

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Keeps information on each threads children */
struct child_status {
  tid_t id;
  bool exit_called;
  bool has_waited;
  int exit_status;
  struct list_elem elem_status;  
};

struct thread
  {
    /* Owned by thread.c. */
    tid_t tid;                          /* Thread identifier. */
    enum thread_status status;          /* Thread state. */
    char name[16];                      /* Name (for debugging purposes). */
    uint8_t *stack;                     /* Saved stack pointer. */
    int priority;                       /* Priority. */
    struct list_elem allelem;           /* List element for all threads list. */

    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

#ifdef USERPROG
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /* Page directory. */
    tid_t parent_id;                    /* parent thread id */
 
    /* signal to indicate the child's executable-loading status:
     *  - 0: has not been loaded
     *  - -1: load failed
     *  - 1: load success*/
    int child_load_status;
    
    /* monitor used to wait the child, owned by wait-syscall and waiting
       for child to load executable */
    struct lock lock_child;
    struct condition cond_child;
 
    /* list of children, which should be a list of struct child_status */
    struct list children;

    /* file struct represents the execuatable of the current thread */ 
    struct file *exec_file;
#endif

    /* Owned by thread.c. */
    unsigned magic;                     /* Detects stack overflow. */

  };

struct file_descripton
{
  int fd_number;
  tid_t owner;
  struct file *file_struct;
  struct list_elem element;
};

/* List constaining open files, the ones open in user process. */
struct list open_files; 

/* The lock that makes sure a single thread accesses the file system at a time. */
struct lock fs_lock;

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

When a file is opened with syscall each file descriptor has its own mapping. A list was created in the kernel which contains the file descriptors as everytime a file is accessed
it has to go through the kernel.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

In order to read we first check whether the buffer has enough capacity/space to hold the read data. Then, we acquire the file system lock. If the thread then has the lock, the lock can be
released and return -1 if fd = STDOUT_FILENO since this is the write operation. If fd = STDIN_FILENO, the keys are acquired from the standard input. We then release the lock and return 0, 
unless the open file needs to be found using the fd number from our list of open files. Then, using file_read in filesys, the status is acquired. Finally the lock is released and status
is returned.

In order to write, we first check to make sure the buffer pointer is valid. Once acquiring the lock, fd is checked. If fd = STDIN_FILENO, the lock is released and -1 is returned as this
is the read operation. If fd = STDOUT_FILENO, putbuf is used to write the buffer to the console. If fd isn't either of these, we will find open file and user the file_write to write the 
buffer. Then, the lock is released and we return the status.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

If a full page of data were to be copied, pagedir_get_page is checked to get a page head back. From the page head we can tell if it will have only one page of data.
The greatest number can be 4096 if not contiguos. If the page is not contiguous each address will need to be checked to make sure we can have valid access.
If contiguos, the greatest number will be 2, checking the start and end pointers.

For 2 bytes of data, the least number of inspections would be 1. This is a full page and if we get back a kernel virtual address we know its in the page.
The greatest number is 2 as if its not contiguos we would only have a total of 2 bytes to check.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

Our wait_syscall is based up our process_wait. We then created a new structure called child_status in order to hold the child exit status.
The parent threads struct contains a list of the child statuses for all the children. Each child will contain its parent_id to have them doubly linked.
Once the child is created and its status is appened to the parent's list, the parent will wait, using cond_wait, until the corresponding child sets the return status and then wakes up
the parent. The parent's struct also contain a monitor in order to avoid potential race conditions. Both the parent and child acquire monitors before checking/setting their status.
If the child were to exit and notifies the parent to wake up, the status will be checked. If the child were to say call exit-syscall in order to exit, then a signal will be sent to set
its exit status in the parent list. If the child were to be killed by the kernel, the corresponding parent will not receive signal and will know that the child was killed by the kernel.
If the parent exits early, the parent's children list will be freed. Then, the children, the chidlren will get signaled to not set their statuses. Then, the children will continue to run.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

initially, we use is_valid_ptr to in order to check if it is a valid user address and to check if its been mapped in process's page directory.
Let's say we write utilizing the system call, we first check the stack pointer and all the arguments in order to ensure validity.
Additionally, we check the buffer ponters in order to make sure they are valid before use. If errors were to occur, we can fix them via page_fault exception.
If we were to check if fault_addr is valid, we can stop the process before the process creates issues. In the bad_jump test, when writing to an invalid address, we check the address before
attempting to write and will stop if needed.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

The child_load_status is saved in the parent thread. With this implementation, if the child were to exit randomly the child will have the value set to fail. It's assumed to have failed
until once confirmed to be successful. This is implemented via monitor. With this implementation, this is how the status is passed to thread that calls execute.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

Before C exists, P calls wait(C) and aquires monitor. The parents will then retrive the exit status
for the corresponding child.

After C exists, P calls wait(C) and aquires monitor. It will then instantly check the exist status
for the child since it exists.

We ensure all resources are freed for each case by:

Before C exists, P terminates without waiting and lock will be released and P list is free.

After C exists, P terminates without waiting and frees all its resuorces.

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

We chose to first validate before use since other implementations seemed more difficult.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

The advantage to our design for file descriptors is:
    The file descriptors in our implementation allows the kernel to access all currently open files.

The advantage to our design for file descriptors is:
    The file descriptors implentation takes alot of kernel storage.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

The mapping was left to its default state.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?


>> Any other comments?
