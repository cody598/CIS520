		     +--------------------------+
       	       	     |		CS 520      	|
		     | PROJECT 2: USER PROGRAMS	|
		     | 	   DESIGN DOCUMENT     	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Jack Johnson <jjohn98@ksu.edu>
Abdulkareem Alkhiary <araasai@ksu.edu>
Cody Morse <cody598@ksu.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

http://www.scs.stanford.edu/07au-cs140/pintos/pintos_3.html
https://www.youtube.com/watch?v=OE79vNZp1KI&ab_channel=FarshadGhanei
https://github.com/danelia/pintos
https://github.com/codyjack/OS-pintos
https://github.com/st2092/pintos-user-programs
https://github.com/Waqee/Pintos-Project-2

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

We did not need to add any new data structures for this section.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

The very first thing we did was set up the page and the stack to be initialized in setup_stack().

Using Process_execute, we can pass in a file_name with commands and arguments. We then tokenize these commands and arguments. We do this so we can pass the arguments into start_process(), load(), and setup_stack(). 

To set up the stack, we memcpy the argument string and thread name. After lining up the strings, we run through the string backwards to get each token. Then, we push the strings address into the page to create argv[]. We then create argv, argc, and the return address.

To get argv[] into the right order, we scan the argument string backwards like I stated previously. This is so that the first token recieved is the last argument and vice versa. Then, all we have to do is decrease the stack pointer to setup the rest of the argv[] elements.

The way we dealt with stack overflows was to just fix the stack pointer when it fails. We figured this would be better than checking it every time, which would have more overhead than just fixing errors.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

We believe the reason for this is that since the kernel separates the commands and arguments, we need to put the address of the arguments aside for use later.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

This shortens kernel time. It is also easier to do things like passing in more than 1 set of commands at a time.

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Keeps information on each threads children */
struct child_status {
  tid_t id;
  bool exit_called;
  bool has_waited;
  int exit_status;
  struct list_elem elem_status;  
};

struct thread
  {
    /* Owned by thread.c. */
    tid_t tid;                          /* Thread identifier. */
    enum thread_status status;          /* Thread state. */
    char name[16];                      /* Name (for debugging purposes). */
    uint8_t *stack;                     /* Saved stack pointer. */
    int priority;                       /* Priority. */
    struct list_elem allelem;           /* List element for all threads list. */

    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

#ifdef USERPROG
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /* Page directory. */
    tid_t parent_id;                    /* parent thread id */
 
    /* signal to indicate the child's executable-loading status:
     *  - 0: has not been loaded
     *  - -1: load failed
     *  - 1: load success*/
    int child_load_status;
    
    /* monitor used to wait the child, owned by wait-syscall and waiting
       for child to load executable */
    struct lock lock_child;
    struct condition cond_child;
 
    /* list of children, which should be a list of struct child_status */
    struct list children;

    /* file struct represents the execuatable of the current thread */ 
    struct file *exec_file;
#endif

    /* Owned by thread.c. */
    unsigned magic;                     /* Detects stack overflow. */

  };

struct file_descripton
{
  int fd_number;
  tid_t owner;
  struct file *file_struct;
  struct list_elem element;
};

/* List constaining open files, the ones open in user process. */
struct list open_files; 

/* The lock that makes sure a single thread accesses the file system at a time. */
struct lock fs_lock;

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

Each file descriptor has its own mapping to a file opened with syscall. We created a list inside the kernel which holds the file desciptors, since everytime you access a filel it has to go throught the kernel.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

To read, we first need to determine whether the buffer has enough space to hold the read. Next, we get the file system lock. Once the current thread has the lock, we can release the lock and return -1 if fd = STDOUT_FILENO, as this is a write operation. If fd = STDIN_FILENO, we get the keys from the standard input. We then release the lock and return 0, unless we need to find the open file using the fd number from the list of open files. Using file_read in filesys, we get the status. Then we finally release the lock and return the status.

To write, we check to make sure the buffer pointer is valid. After aquiring the lock, we again check fd. If fd = STDIN_FILENO, we release the lock and return -1 as this is a read operation. If fd = STDOUT_FILENO, we use putbuf to write the buffer to the console. If fd isn't one of these two, we find the open file and use file_write to write the buffer. We then release the lock and return the status.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

If a whole page of data is being copied, we first check pagedir_get_page to get a page head back. From this we can tell if it will only contain one page of data. But, the greatest number could be 4096 if its not contiguous. If it isn't contiguous, we would have to check each address to make sure we have valid access. If its contiguous, the greatest number would be 2, checking the start and end pointer.

For 2 bytes of data, the least number of inspections would be 1. This is the same as a full page, if we get back a kernel virtual address we know its in the page. The greatest number would be 2, because even if its not contiguous we would only have 2 bytes to check.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

Our wait_syscall is based on process_wait. We created a new structure called child_status to hold the childs exit status. The parent threads struct then contains a list of child statuses for all of its children. Each child also contains its parent_id so that they are doubly linked. After the child is created and has its status added to its parent's list, the parent will wait(cond_wait) until the child sets its return status and wakes up the parent. The parent's struct also contains a monitor to avoid race conditions. The parent and child both aquire monitors before checking or setting their status. Once the child exits and notifies the parent to wake up, it will check its status. If the child calls exit-syscall to exit, it will send a signal to set its exit status in the parent's list. If the child is killed by the kernel, the parent will not recieve the signal and know that it was killed by the kernel. In case the parent exits early, the list of children in the parent will be freed, and then the children will get a signal and not try to set their statuses, and they will continue to run.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

To start, we use is_valid_ptr to check if it is a valid user address and if it's been mapped in the process's page directory. For example, when we write using the system call, we check the stack pointer and all the arguments first to ensure validity. Beyond this, we also check the buffer pointers to make sure they are valid before being used. If any error were to still occur, we can fix it in the page_fault exception. By checking if the fault_addr is valid, we can stop the process before it creates any issues. This is like how in the bad jump 2 test, when it tries to write to an invalid address, we can check the address before it attempts to write and stop it if need be.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

We have the child_load_status saved in the parent thread. This way, even if the child exits randomly, the child will have its value set to fail. So it is assumed to have failed until confirmed to have been successful. This is implemented using a monitor. This is also how the status is passed back to the thread that calls execute. 

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

Before C exists, P calls wait(C) and aquires monitor. The parents will then retrive the exit status
for the child

After C exists, P calls wait(C) and aquires monitor. It will then instantly check the exist status
for the child since it exists.

I ensure that all resuorces are freed in each case by

Before C exists, P terminates without waiting and lock will be released and P list is free.

After C exists, P terminates without waiting and frees all its resuorces.

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

We chose to validate before using it because the other possible implementations seemed more difficult.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

The advantage to our desgin for file descriptors would be:
    The file descriptors design allows the kernel to access all the open files

The disadvantage to our desgin for file descriptors would be:
    The file descriptors design takes too much kernel storage

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We left the mapping default.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
